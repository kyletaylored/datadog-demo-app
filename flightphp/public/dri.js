(function (d, l) { typeof exports == "object" && typeof module != "undefined" ? module.exports = l() : typeof define == "function" && define.amd ? define(l) : (d = typeof globalThis != "undefined" ? globalThis : d || self, d.DD_RUM_INTERCEPTOR = l()) })(this, function () {
    "use strict"; var kt = Object.defineProperty, Ut = Object.defineProperties; var $t = Object.getOwnPropertyDescriptors; var Ae = Object.getOwnPropertySymbols; var Xt = Object.prototype.hasOwnProperty, Ft = Object.prototype.propertyIsEnumerable; var _e = d => { throw TypeError(d) }; var ne = (d, l, h) => l in d ? kt(d, l, { enumerable: !0, configurable: !0, writable: !0, value: h }) : d[l] = h, je = (d, l) => { for (var h in l || (l = {})) Xt.call(l, h) && ne(d, h, l[h]); if (Ae) for (var h of Ae(l)) Ft.call(l, h) && ne(d, h, l[h]); return d }, Me = (d, l) => Ut(d, $t(l)); var I = (d, l, h) => ne(d, typeof l != "symbol" ? l + "" : l, h), oe = (d, l, h) => l.has(d) || _e("Cannot " + h); var U = (d, l, h) => (oe(d, l, "read from private field"), h ? h.call(d) : l.get(d)), ie = (d, l, h) => l.has(d) ? _e("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(d) : l.set(d, h), Be = (d, l, h, O) => (oe(d, l, "write to private field"), O ? O.call(d, h) : l.set(d, h), h), G = (d, l, h) => (oe(d, l, "access private method"), h); var g = (d, l, h) => new Promise((O, R) => { var x = w => { try { D(h.next(w)) } catch (j) { R(j) } }, q = w => { try { D(h.throw(w)) } catch (j) { R(j) } }, D = w => w.done ? O(w.value) : Promise.resolve(w.value).then(x, q); D((h = h.apply(d, l)).next()) }); var T, A, N, De; var d = new TextEncoder; function l(e) { return d.encode(e) } function h(e, t) { return new TextDecoder(t).decode(e) } function O(e) { return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength) } var R = Symbol("isPatchedModule"), x = class extends Response { static isConfigurableStatusCode(e) { return e >= 200 && e <= 599 } static isRedirectResponse(e) { return x.STATUS_CODES_WITH_REDIRECT.includes(e) } static isResponseWithBody(e) { return !x.STATUS_CODES_WITHOUT_BODY.includes(e) } static setUrl(e, t) { e && t.url == "" && Object.defineProperty(t, "url", { value: e, enumerable: !0, configurable: !0, writable: !1 }) } static parseRawHeaders(e) { const t = new Headers; for (let r = 0; r < e.length; r += 2)t.append(e[r], e[r + 1]); return t } constructor(e, t = {}) { var r; const s = (r = t.status) != null ? r : 200, n = x.isConfigurableStatusCode(s) ? s : 200, o = x.isResponseWithBody(s) ? e : null; if (super(o, Me(je({}, t), { status: n })), s !== n) { const i = Object.getOwnPropertySymbols(this).find(a => a.description === "state"); if (i) { const a = Reflect.get(this, i); Reflect.set(a, "status", s) } else Object.defineProperty(this, "status", { value: s, enumerable: !0, configurable: !0, writable: !1 }) } x.setUrl(t.url, this) } }, q = x; q.STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304], q.STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]; function D() { if (typeof navigator != "undefined" && navigator.product === "ReactNative") return !0; if (typeof process != "undefined") { const e = process.type; return e === "renderer" || e === "worker" ? !1 : !!(process.versions && process.versions.node) } return !1 } var w = /(%?)(%([sdijo]))/g; function j(e, t) { switch (t) { case "s": return e; case "d": case "i": return Number(e); case "j": return JSON.stringify(e); case "o": { if (typeof e == "string") return e; const r = JSON.stringify(e); return r === "{}" || r === "[]" || /^\[object .+?\]$/.test(r) ? e : r } } } function M(e, ...t) { if (t.length === 0) return e; let r = 0, s = e.replace(w, (n, o, i, a) => { const c = t[r], u = j(c, a); return o ? n : (r++, u) }); return r < t.length && (s += ` ${t.slice(r).join(" ")}`), s = s.replace(/%{2,2}/g, "%"), s } var Ce = 2; function ke(e) {
        if (!e.stack) return; const t = e.stack.split(`
`); t.splice(1, Ce), e.stack = t.join(`
`)
    } var Ue = class extends Error { constructor(e, ...t) { super(e), this.message = e, this.name = "Invariant Violation", this.message = M(e, ...t), ke(this) } }, S = (e, t, ...r) => { if (!e) throw new Ue(t, ...r) }; S.as = (e, t, r, ...s) => { if (!t) { const n = s.length === 0 ? r : M(r, ...s); let o; try { o = Reflect.construct(e, [n]) } catch (i) { o = e(n) } throw o } }; var $e = Object.defineProperty, Xe = (e, t) => { for (var r in t) $e(e, r, { get: t[r], enumerable: !0 }) }, J = {}; Xe(J, { blue: () => We, gray: () => z, green: () => Ne, red: () => Ge, yellow: () => Fe }); function Fe(e) { return `\x1B[33m${e}\x1B[0m` } function We(e) { return `\x1B[34m${e}\x1B[0m` } function z(e) { return `\x1B[90m${e}\x1B[0m` } function Ge(e) { return `\x1B[31m${e}\x1B[0m` } function Ne(e) { return `\x1B[32m${e}\x1B[0m` } var $ = D(), ae = class { constructor(e) { I(this, "prefix"); this.name = e, this.prefix = `[${this.name}]`; const t = ue("DEBUG"), r = ue("LOG_LEVEL"); t === "1" || t === "true" || typeof t != "undefined" && this.name.startsWith(t) ? (this.debug = B(r, "debug") ? v : this.debug, this.info = B(r, "info") ? v : this.info, this.success = B(r, "success") ? v : this.success, this.warning = B(r, "warning") ? v : this.warning, this.error = B(r, "error") ? v : this.error) : (this.info = v, this.success = v, this.warning = v, this.error = v, this.only = v) } extend(e) { return new ae(`${this.name}:${e}`) } debug(e, ...t) { this.logEntry({ level: "debug", message: z(e), positionals: t, prefix: this.prefix, colors: { prefix: "gray" } }) } info(e, ...t) { this.logEntry({ level: "info", message: e, positionals: t, prefix: this.prefix, colors: { prefix: "blue" } }); const r = new Je; return (s, ...n) => { r.measure(), this.logEntry({ level: "info", message: `${s} ${z(`${r.deltaTime}ms`)}`, positionals: n, prefix: this.prefix, colors: { prefix: "blue" } }) } } success(e, ...t) { this.logEntry({ level: "info", message: e, positionals: t, prefix: `✔ ${this.prefix}`, colors: { timestamp: "green", prefix: "green" } }) } warning(e, ...t) { this.logEntry({ level: "warning", message: e, positionals: t, prefix: `⚠ ${this.prefix}`, colors: { timestamp: "yellow", prefix: "yellow" } }) } error(e, ...t) { this.logEntry({ level: "error", message: e, positionals: t, prefix: `✖ ${this.prefix}`, colors: { timestamp: "red", prefix: "red" } }) } only(e) { e() } createEntry(e, t) { return { timestamp: new Date, level: e, message: t } } logEntry(e) { const { level: t, message: r, prefix: s, colors: n, positionals: o = [] } = e, i = this.createEntry(t, r), a = (n == null ? void 0 : n.timestamp) || "gray", c = (n == null ? void 0 : n.prefix) || "gray", u = { timestamp: J[a], prefix: J[c] }; this.getWriter(t)([u.timestamp(this.formatTimestamp(i.timestamp))].concat(s != null ? u.prefix(s) : []).concat(le(r)).join(" "), ...o.map(le)) } formatTimestamp(e) { return `${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}` } getWriter(e) { switch (e) { case "debug": case "success": case "info": return ze; case "warning": return Ve; case "error": return Ye } } }, Je = class { constructor() { I(this, "startTime"); I(this, "endTime"); I(this, "deltaTime"); this.startTime = performance.now() } measure() { this.endTime = performance.now(); const e = this.endTime - this.startTime; this.deltaTime = e.toFixed(2) } }, v = () => { }; function ze(e, ...t) {
        if ($) {
            process.stdout.write(M(e, ...t) + `
`); return
        } console.log(e, ...t)
    } function Ve(e, ...t) {
        if ($) {
            process.stderr.write(M(e, ...t) + `
`); return
        } console.warn(e, ...t)
    } function Ye(e, ...t) {
        if ($) {
            process.stderr.write(M(e, ...t) + `
`); return
        } console.error(e, ...t)
    } function ue(e) { var t; return $ ? process.env[e] : (t = globalThis[e]) == null ? void 0 : t.toString() } function B(e, t) { return e !== void 0 && e !== t } function le(e) { return typeof e == "undefined" ? "undefined" : e === null ? "null" : typeof e == "string" ? e : typeof e == "object" ? JSON.stringify(e) : e.toString() } var Qe = class extends Error { constructor(e, t, r) { super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`), this.emitter = e, this.type = t, this.count = r, this.name = "MaxListenersExceededWarning" } }, ce = class { static listenerCount(e, t) { return e.listenerCount(t) } constructor() { this.events = new Map, this.maxListeners = ce.defaultMaxListeners, this.hasWarnedAboutPotentialMemoryLeak = !1 } _emitInternalEvent(e, t, r) { this.emit(e, t, r) } _getListeners(e) { return Array.prototype.concat.apply([], this.events.get(e)) || [] } _removeListener(e, t) { const r = e.indexOf(t); return r > -1 && e.splice(r, 1), [] } _wrapOnceListener(e, t) { const r = (...s) => (this.removeListener(e, r), t.apply(this, s)); return Object.defineProperty(r, "name", { value: t.name }), r } setMaxListeners(e) { return this.maxListeners = e, this } getMaxListeners() { return this.maxListeners } eventNames() { return Array.from(this.events.keys()) } emit(e, ...t) { const r = this._getListeners(e); return r.forEach(s => { s.apply(this, t) }), r.length > 0 } addListener(e, t) { this._emitInternalEvent("newListener", e, t); const r = this._getListeners(e).concat(t); if (this.events.set(e, r), this.maxListeners > 0 && this.listenerCount(e) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) { this.hasWarnedAboutPotentialMemoryLeak = !0; const s = new Qe(this, e, this.listenerCount(e)); console.warn(s) } return this } on(e, t) { return this.addListener(e, t) } once(e, t) { return this.addListener(e, this._wrapOnceListener(e, t)) } prependListener(e, t) { const r = this._getListeners(e); if (r.length > 0) { const s = [t].concat(r); this.events.set(e, s) } else this.events.set(e, r.concat(t)); return this } prependOnceListener(e, t) { return this.prependListener(e, this._wrapOnceListener(e, t)) } removeListener(e, t) { const r = this._getListeners(e); return r.length > 0 && (this._removeListener(r, t), this.events.set(e, r), this._emitInternalEvent("removeListener", e, t)), this } off(e, t) { return this.removeListener(e, t) } removeAllListeners(e) { return e ? this.events.delete(e) : this.events.clear(), this } listeners(e) { return Array.from(this._getListeners(e)) } listenerCount(e) { return this._getListeners(e).length } rawListeners(e) { return this.listeners(e) } }, de = ce; de.defaultMaxListeners = 10; var Ke = "x-interceptors-internal-request-id"; function he(e) { return globalThis[e] || void 0 } function Ze(e, t) { globalThis[e] = t } function et(e) { delete globalThis[e] } var V = class { constructor(e) { this.symbol = e, this.readyState = "INACTIVE", this.emitter = new de, this.subscriptions = [], this.logger = new ae(e.description), this.emitter.setMaxListeners(0), this.logger.info("constructing the interceptor...") } checkEnvironment() { return !0 } apply() { const e = this.logger.extend("apply"); if (e.info("applying the interceptor..."), this.readyState === "APPLIED") { e.info("intercepted already applied!"); return } if (!this.checkEnvironment()) { e.info("the interceptor cannot be applied in this environment!"); return } this.readyState = "APPLYING"; const r = this.getInstance(); if (r) { e.info("found a running instance, reusing..."), this.on = (s, n) => (e.info('proxying the "%s" listener', s), r.emitter.addListener(s, n), this.subscriptions.push(() => { r.emitter.removeListener(s, n), e.info('removed proxied "%s" listener!', s) }), this), this.readyState = "APPLIED"; return } e.info("no running instance found, setting up a new instance..."), this.setup(), this.setInstance(), this.readyState = "APPLIED" } setup() { } on(e, t) { const r = this.logger.extend("on"); return this.readyState === "DISPOSING" || this.readyState === "DISPOSED" ? (r.info("cannot listen to events, already disposed!"), this) : (r.info('adding "%s" event listener:', e, t), this.emitter.on(e, t), this) } once(e, t) { return this.emitter.once(e, t), this } off(e, t) { return this.emitter.off(e, t), this } removeAllListeners(e) { return this.emitter.removeAllListeners(e), this } dispose() { const e = this.logger.extend("dispose"); if (this.readyState === "DISPOSED") { e.info("cannot dispose, already disposed!"); return } if (e.info("disposing the interceptor..."), this.readyState = "DISPOSING", !this.getInstance()) { e.info("no interceptors running, skipping dispose..."); return } if (this.clearInstance(), e.info("global symbol deleted:", he(this.symbol)), this.subscriptions.length > 0) { e.info("disposing of %d subscriptions...", this.subscriptions.length); for (const t of this.subscriptions) t(); this.subscriptions = [], e.info("disposed of all subscriptions!", this.subscriptions.length) } this.emitter.removeAllListeners(), e.info("destroyed the listener!"), this.readyState = "DISPOSED" } getInstance() { var e; const t = he(this.symbol); return this.logger.info("retrieved global instance:", (e = t == null ? void 0 : t.constructor) == null ? void 0 : e.name), t } setInstance() { Ze(this.symbol, this), this.logger.info("set global instance!", this.symbol.description) } clearInstance() { et(this.symbol), this.logger.info("cleared global instance!", this.symbol.description) } }; function fe() { return Math.random().toString(16).slice(2) } var Y = class extends V { constructor(e) { Y.symbol = Symbol(e.name), super(Y.symbol), this.interceptors = e.interceptors } setup() { const e = this.logger.extend("setup"); e.info("applying all %d interceptors...", this.interceptors.length); for (const t of this.interceptors) e.info('applying "%s" interceptor...', t.constructor.name), t.apply(), e.info("adding interceptor dispose subscription"), this.subscriptions.push(() => t.dispose()) } on(e, t) { for (const r of this.interceptors) r.on(e, t); return this } once(e, t) { for (const r of this.interceptors) r.once(e, t); return this } off(e, t) { for (const r of this.interceptors) r.off(e, t); return this } removeAllListeners(e) { for (const t of this.interceptors) t.removeAllListeners(e); return this } }; let pe = !1; function tt(e) { pe = e } const y = new Proxy(console, { get: (e, t) => (...r) => { var s; return pe && ((s = e[t]) == null ? void 0 : s.call(e, "[Datadog Interceptor]:", ...r)) } }); function ge(e) { if (!(e instanceof Headers)) throw new Error("The object provided must be an instance of Headers."); const t = {}; for (const [r, s] of e.entries()) t[r] = s; return t } function me(e) { if (e.url.includes("datadoghq.com")) return !0 } function ye(e) { let t = 0; for (let r = 0; r < e.length; r++) { const s = e.charCodeAt(r); t = (t << 5) - t + s, t = t & t } return Math.abs(t).toString(16).padStart(32, "0") } function rt(e) { var t; try { if (!((t = e == null ? void 0 : e.requestInit) != null && t.headers) || !Array.isArray(e.requestInit.headers)) return null; const r = e.requestInit.headers.find(s => Array.isArray(s) && s[0] === "x-datadog-trace-id"); return r ? r[1] : null } catch (r) { return y.error("Error getting trace ID:", r), null } } function st(e) { return g(this, null, function* () { const t = yield e.clone(); return { method: "method" in t ? t.method : null, headers: ge(t.headers), body: yield nt(t.body), url: t.url, status: "status" in t ? t.status : null, timestamp: Date.now() } }) } function nt(e) { return g(this, null, function* () { if (!e) return null; const t = typeof process != "undefined" && process.versions != null && process.versions.node != null; let r; try { if (typeof e == "string") r = e; else if (typeof ReadableStream != "undefined" && e instanceof ReadableStream) r = yield new Response(e).text(); else if (t && typeof Buffer != "undefined" && Buffer.isBuffer(e)) r = e.toString("utf-8"); else return y.warn("Unsupported body type:", typeof e), null; const s = r.trim(); if (s.startsWith("{") || s.startsWith("[")) try { return JSON.parse(s) } catch (n) { return y.warn("Failed to parse JSON body:", n), r } return s; if (s.startsWith("<") && !s.toLowerCase().startsWith("<html") && !s.toLowerCase().startsWith("<!doctype html")) try { if (typeof DOMParser == "undefined") { const { JSDOM: n } = require("jsdom"), o = new n, a = new o.window.DOMParser().parseFromString(s, "text/xml"), c = a.querySelector("parsererror"); if (c) throw new Error(c.textContent); return a } else { const o = new DOMParser().parseFromString(s, "text/xml"), i = o.querySelector("parsererror"); if (i) throw new Error(i.textContent); return o } } catch (n) { return y.warn("Failed to parse XML body:", n), r } } catch (s) { return y.error("Error parsing body:", s), null } }) } function ot(e) { const t = new Headers; return e && e.trim().split(/[\r\n]+/).forEach(r => { const s = r.split(": "), n = s.shift().trim(), o = s.join(": ").trim(); n && t.append(n, o) }), t } function it(e) { if (!e || typeof e != "object") return ""; function t(s) { return Array.isArray(s) ? s.map(t) : s !== null && typeof s == "object" ? Object.keys(s).sort().reduce((n, o) => (n[o] = t(s[o]), n), {}) : s } const r = JSON.stringify(t(e)); return ye(r) } const X = new Map, Q = new Map, at = 5e3; function ut(e, t) { X.set(e, t), setTimeout(() => { X.delete(e) }, at) } function lt(e) { const t = X.get(e); return X.delete(e), t || null } function ct(e, t) { Q.set(e, t) } function dt(e) { const t = Q.get(e); return Q.delete(e), t || null } function be(e, t = "default") { if (!e) return null; try { const r = e.method || "GET", s = e.url || "", n = e.status || 200, o = Math.floor(e.timestamp / 1e4), i = it(e.headers) || "", a = `${r}:${s}:${n}:${i}:${o}`, c = ye(a); return y.log(`Debug fingerprint (${t}):`, { data: e, fingerprintString: a, fingerprint: c }), c } catch (r) { return y.error("Error generating fingerprint:", r), null } } function ht(e, t) { const { debug: r = !1 } = e || {}; tt(r); const s = new Y({ name: "datadog-rum-interceptor", interceptors: t }); s.apply(), s.on("request", c => g(this, [c], function* ({ request: i, requestId: a }) { if (me(i)) return; const u = { method: i.method, url: i.url, headers: Object.fromEntries(i.headers.entries()), timestamp: Date.now() }; ut(a, u), y.log(`Intercepted Request: ${i.url}`, u) })), s.on("response", u => g(this, [u], function* ({ request: i, response: a, requestId: c }) { var b; if (me(i)) return; const f = lt(c); if (!f) { y.warn(`No matching request found for response: ${a.url}`); return } const p = yield st(a); Object.keys(p).forEach(L => { (p[L] === null || p[L] === "") && f[L] !== void 0 && (p[L] = f[L]) }); const m = (b = i.headers.get("x-datadog-trace-id")) != null ? b : be(p, "interceptor "), _ = { request: f, response: p }; ct(m, _), y.log(`Intercepted Response: ${a.url}`, _) })); function n(i) { var p, m, _, b, L; if (!i || typeof i != "object") return console.warn("Invalid beforeSend object provided."), null; const { event: a, context: c } = i; if (!a || !c) return console.warn("Both `event` and `context` are required."), null; const f = ((p = a.resource) == null ? void 0 : p.type) === "xhr" ? ot(c.xhr.getAllResponseHeaders()) : c.response.headers; try { const se = (L = rt(c)) != null ? L : be({ method: ((m = a.resource) == null ? void 0 : m.method) || "GET", url: ((_ = a.resource) == null ? void 0 : _.url) || "", status: ((b = a.resource) == null ? void 0 : b.status_code) || "", timestamp: a.date || Date.now(), headers: ge(f) }, "extractor"), He = dt(se); return He || y.warn("No match found for request:", c), He } catch (se) { return y.error("Failed to extract resource data:", se), null } } function o() { s.dispose(), y.info("Interceptor stopped.") } return { stop: o, getPayload: n } } function ft() { const e = (t, r) => { e.state = "pending", e.resolve = s => { if (e.state !== "pending") return; e.result = s; const n = o => (e.state = "fulfilled", o); return t(s instanceof Promise ? s : Promise.resolve(s).then(n)) }, e.reject = s => { if (e.state === "pending") return queueMicrotask(() => { e.state = "rejected" }), r(e.rejectionReason = s) } }; return e } var K = (De = class extends Promise { constructor(t = null) { const r = ft(); super((s, n) => { r(s, n), t == null || t(r.resolve, r.reject) }); ie(this, A); ie(this, T); I(this, "resolve"); I(this, "reject"); Be(this, T, r), this.resolve = U(this, T).resolve, this.reject = U(this, T).reject } get state() { return U(this, T).state } get rejectionReason() { return U(this, T).rejectionReason } then(t, r) { return G(this, A, N).call(this, super.then(t, r)) } catch(t) { return G(this, A, N).call(this, super.catch(t)) } finally(t) { return G(this, A, N).call(this, super.finally(t)) } }, T = new WeakMap, A = new WeakSet, N = function (t) { return Object.defineProperties(t, { resolve: { configurable: !0, value: this.resolve }, reject: { configurable: !0, value: this.reject } }) }, De), ve = e => g(this, null, function* () { try { return { error: null, data: yield e().catch(r => { throw r }) } } catch (t) { return { error: t, data: null } } }), F = class extends Error { constructor(e) { super(e), this.name = "InterceptorError", Object.setPrototypeOf(this, F.prototype) } }, C = Symbol("kRequestHandled"), E = Symbol("kResponsePromise"), Z = class { constructor(e) { this.request = e, this[C] = !1, this[E] = new K } respondWith(e) { S.as(F, !this[C], 'Failed to respond to the "%s %s" request: the "request" event has already been handled.', this.request.method, this.request.url), this[C] = !0, this[E].resolve(e) } errorWith(e) { S.as(F, !this[C], 'Failed to error the "%s %s" request: the "request" event has already been handled.', this.request.method, this.request.url), this[C] = !0, this[E].resolve(e) } }; function W(e, t, ...r) { return g(this, null, function* () { const s = e.listeners(t); if (s.length !== 0) for (const n of s) yield n.apply(e, r) }) } function pt(e, t) { try { return e[t], !0 } catch (r) { return !1 } } function gt(e) { return new Response(JSON.stringify(e instanceof Error ? { name: e.name, message: e.message, stack: e.stack } : e), { status: 500, statusText: "Unhandled Exception", headers: { "Content-Type": "application/json" } }) } function mt(e) { return pt(e, "type") && e.type === "error" } function yt(e) { return e == null || !(e instanceof Error) ? !1 : "code" in e && "errno" in e } function Ee(e) { return g(this, null, function* () { const t = o => g(this, null, function* () { return o instanceof Error ? e.onError(o) : mt(o) ? e.onRequestError(o) : yield e.onResponse(o), !0 }), r = o => g(this, null, function* () { if (o instanceof F) throw n.error; return yt(o) ? (e.onError(o), !0) : o instanceof Response ? yield t(o) : !1 }); e.emitter.once("request", ({ requestId: o }) => { o === e.requestId && e.controller[E].state === "pending" && e.controller[E].resolve(void 0) }); const s = new K; e.request.signal && (e.request.signal.aborted ? s.reject(e.request.signal.reason) : e.request.signal.addEventListener("abort", () => { s.reject(e.request.signal.reason) }, { once: !0 })); const n = yield ve(() => g(this, null, function* () { const o = W(e.emitter, "request", { requestId: e.requestId, request: e.request, controller: e.controller }); return yield Promise.race([s, o, e.controller[E]]), yield e.controller[E] })); if (s.state === "rejected") return e.onError(s.rejectionReason), !0; if (n.error) { if (yield r(n.error)) return !0; if (e.emitter.listenerCount("unhandledException") > 0) { const o = new Z(e.request); yield W(e.emitter, "unhandledException", { error: n.error, request: e.request, requestId: e.requestId, controller: o }).then(() => { o[E].state === "pending" && o[E].resolve(void 0) }); const i = yield ve(() => o[E]); if (i.error) return r(i.error); if (i.data) return t(i.data) } return e.onResponse(gt(n.error)), !0 } return n.data ? t(n.data) : !1 }) } function Re(e) { const t = Object.getOwnPropertyDescriptor(globalThis, e); return typeof t == "undefined" || typeof t.get == "function" && typeof t.get() == "undefined" || typeof t.get == "undefined" && t.value == null ? !1 : typeof t.set == "undefined" && !t.configurable ? (console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`), !1) : !0 } function bt(e) { try { return new URL(e), !0 } catch (t) { return !1 } } function P(e) { return Object.assign(new TypeError("Failed to fetch"), { cause: e }) } var vt = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], ee = Symbol("kRedirectCount"); function Et(e, t) { return g(this, null, function* () { if (t.status !== 303 && e.body != null) return Promise.reject(P()); const r = new URL(e.url); let s; try { s = new URL(t.headers.get("location"), e.url) } catch (o) { return Promise.reject(P(o)) } if (!(s.protocol === "http:" || s.protocol === "https:")) return Promise.reject(P("URL scheme must be a HTTP(S) scheme")); if (Reflect.get(e, ee) > 20) return Promise.reject(P("redirect count exceeded")); if (Object.defineProperty(e, ee, { value: (Reflect.get(e, ee) || 0) + 1 }), e.mode === "cors" && (s.username || s.password) && !qe(r, s)) return Promise.reject(P('cross origin not allowed for request mode "cors"')); const n = {}; return ([301, 302].includes(t.status) && e.method === "POST" || t.status === 303 && !["HEAD", "GET"].includes(e.method)) && (n.method = "GET", n.body = null, vt.forEach(o => { e.headers.delete(o) })), qe(r, s) || (e.headers.delete("authorization"), e.headers.delete("proxy-authorization"), e.headers.delete("cookie"), e.headers.delete("host")), n.headers = e.headers, fetch(new Request(s, n)) }) } function qe(e, t) { return e.origin === t.origin && e.origin === "null" || e.protocol === t.protocol && e.hostname === t.hostname && e.port === t.port } var Rt = class extends TransformStream { constructor() { console.warn("[Interceptors]: Brotli decompression of response streams is not supported in the browser"), super({ transform(e, t) { t.enqueue(e) } }) } }, qt = class extends TransformStream { constructor(e, ...t) { super({}, ...t); const r = [super.readable, ...e].reduce((s, n) => s.pipeThrough(n)); Object.defineProperty(this, "readable", { get() { return r } }) } }; function wt(e) { return e.toLowerCase().split(",").map(t => t.trim()) } function xt(e) { if (e === "") return null; const t = wt(e); if (t.length === 0) return null; const r = t.reduceRight((s, n) => n === "gzip" || n === "x-gzip" ? s.concat(new DecompressionStream("gzip")) : n === "deflate" ? s.concat(new DecompressionStream("deflate")) : n === "br" ? s.concat(new Rt) : (s.length = 0, s), []); return new qt(r) } function Tt(e) { if (e.body === null) return null; const t = xt(e.headers.get("content-encoding") || ""); return t ? (e.body.pipeTo(t.writable), t.readable) : null } var we = class extends V { constructor() { super(we.symbol) } checkEnvironment() { return Re("fetch") } setup() { return g(this, null, function* () { const e = globalThis.fetch; S(!e[R], 'Failed to patch the "fetch" module: already patched.'), globalThis.fetch = (t, r) => g(this, null, function* () { const s = fe(), n = typeof t == "string" && typeof location != "undefined" && !bt(t) ? new URL(t, location.origin) : t, o = new Request(n, r), i = new K, a = new Z(o); return this.logger.info("[%s] %s", o.method, o.url), this.logger.info("awaiting for the mocked response..."), this.logger.info('emitting the "request" event for %s listener(s)...', this.emitter.listenerCount("request")), (yield Ee({ request: o, requestId: s, emitter: this.emitter, controller: a, onResponse: u => g(this, null, function* () { this.logger.info("received mocked response!", { rawResponse: u }); const f = Tt(u), p = f === null ? u : new q(f, u); if (q.setUrl(o.url, p), q.isRedirectResponse(p.status)) { if (o.redirect === "error") { i.reject(P("unexpected redirect")); return } if (o.redirect === "follow") { Et(o, p).then(m => { i.resolve(m) }, m => { i.reject(m) }); return } } this.emitter.listenerCount("response") > 0 && (this.logger.info('emitting the "response" event...'), yield W(this.emitter, "response", { response: p.clone(), isMockedResponse: !0, request: o, requestId: s })), i.resolve(p) }), onRequestError: u => { this.logger.info("request has errored!", { response: u }), i.reject(P(u)) }, onError: u => { this.logger.info("request has been aborted!", { error: u }), i.reject(u) } })) ? (this.logger.info("request has been handled, returning mock promise..."), i) : (this.logger.info("no mocked response received, performing request as-is..."), e(o).then(u => g(this, null, function* () { if (this.logger.info("original fetch performed", u), this.emitter.listenerCount("response") > 0) { this.logger.info('emitting the "response" event...'); const f = u.clone(); yield W(this.emitter, "response", { response: f, isMockedResponse: !1, request: o, requestId: s }) } return u }))) }), Object.defineProperty(globalThis.fetch, R, { enumerable: !0, configurable: !0, value: !0 }), this.subscriptions.push(() => { Object.defineProperty(globalThis.fetch, R, { value: void 0 }), globalThis.fetch = e, this.logger.info('restored native "globalThis.fetch"!', globalThis.fetch.name) }) }) } }, xe = we; xe.symbol = Symbol("fetch"); function Lt(e, t) { const r = new Uint8Array(e.byteLength + t.byteLength); return r.set(e, 0), r.set(t, e.byteLength), r } var Te = class { constructor(e, t) { this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.type = "", this.srcElement = null, this.currentTarget = null, this.eventPhase = 0, this.isTrusted = !0, this.composed = !1, this.cancelable = !0, this.defaultPrevented = !1, this.bubbles = !0, this.lengthComputable = !0, this.loaded = 0, this.total = 0, this.cancelBubble = !1, this.returnValue = !0, this.type = e, this.target = (t == null ? void 0 : t.target) || null, this.currentTarget = (t == null ? void 0 : t.currentTarget) || null, this.timeStamp = Date.now() } composedPath() { return [] } initEvent(e, t, r) { this.type = e, this.bubbles = !!t, this.cancelable = !!r } preventDefault() { this.defaultPrevented = !0 } stopPropagation() { } stopImmediatePropagation() { } }, St = class extends Te { constructor(e, t) { super(e), this.lengthComputable = (t == null ? void 0 : t.lengthComputable) || !1, this.composed = (t == null ? void 0 : t.composed) || !1, this.loaded = (t == null ? void 0 : t.loaded) || 0, this.total = (t == null ? void 0 : t.total) || 0 } }, Pt = typeof ProgressEvent != "undefined"; function It(e, t, r) { const s = ["error", "progress", "loadstart", "loadend", "load", "timeout", "abort"], n = Pt ? ProgressEvent : St; return s.includes(t) ? new n(t, { lengthComputable: !0, loaded: (r == null ? void 0 : r.loaded) || 0, total: (r == null ? void 0 : r.total) || 0 }) : new Te(t, { target: e, currentTarget: e }) } function Le(e, t) { if (!(t in e)) return null; if (Object.prototype.hasOwnProperty.call(e, t)) return e; const s = Reflect.getPrototypeOf(e); return s ? Le(s, t) : null } function te(e, t) { return new Proxy(e, Ot(t)) } function Ot(e) { const { constructorCall: t, methodCall: r, getProperty: s, setProperty: n } = e, o = {}; return typeof t != "undefined" && (o.construct = function (i, a, c) { const u = Reflect.construct.bind(null, i, a, c); return t.call(c, a, u) }), o.set = function (i, a, c) { const u = () => { const f = Le(i, a) || i, p = Reflect.getOwnPropertyDescriptor(f, a); return typeof (p == null ? void 0 : p.set) != "undefined" ? (p.set.apply(i, [c]), !0) : Reflect.defineProperty(f, a, { writable: !0, enumerable: !0, configurable: !0, value: c }) }; return typeof n != "undefined" ? n.call(i, [a, c], u) : u() }, o.get = function (i, a, c) { const u = () => i[a], f = typeof s != "undefined" ? s.call(i, [a, c], u) : u(); return typeof f == "function" ? (...p) => { const m = f.bind(i, ...p); return typeof r != "undefined" ? r.call(i, [a, p], m) : m() } : f }, o } function Dt(e) { return ["application/xhtml+xml", "application/xml", "image/svg+xml", "text/html", "text/xml"].some(r => e.startsWith(r)) } function Ht(e) { try { return JSON.parse(e) } catch (t) { return null } } function At(e, t) { const r = q.isResponseWithBody(e.status) ? t : null; return new q(r, { url: e.responseURL, status: e.status, statusText: e.statusText, headers: _t(e.getAllResponseHeaders()) }) } function _t(e) { const t = new Headers, r = e.split(/[\r\n]+/); for (const s of r) { if (s.trim() === "") continue; const [n, ...o] = s.split(": "), i = o.join(": "); t.append(n, i) } return t } function Se(e) { return g(this, null, function* () { const t = e.headers.get("content-length"); return t != null && t !== "" ? Number(t) : (yield e.arrayBuffer()).byteLength }) } var k = Symbol("kIsRequestHandled"), jt = D(), re = Symbol("kFetchRequest"), Mt = class {
        constructor(e, t) { this.initialRequest = e, this.logger = t, this.method = "GET", this.url = null, this[k] = !1, this.events = new Map, this.uploadEvents = new Map, this.requestId = fe(), this.requestHeaders = new Headers, this.responseBuffer = new Uint8Array, this.request = te(e, { setProperty: ([r, s], n) => { switch (r) { case "ontimeout": { const o = r.slice(2); return this.request.addEventListener(o, s), n() } default: return n() } }, methodCall: ([r, s], n) => { var o; switch (r) { case "open": { const [i, a] = s; return typeof a == "undefined" ? (this.method = "GET", this.url = Pe(i)) : (this.method = i, this.url = Pe(a)), this.logger = this.logger.extend(`${this.method} ${this.url.href}`), this.logger.info("open", this.method, this.url.href), n() } case "addEventListener": { const [i, a] = s; return this.registerEvent(i, a), this.logger.info("addEventListener", i, a), n() } case "setRequestHeader": { const [i, a] = s; return this.requestHeaders.set(i, a), this.logger.info("setRequestHeader", i, a), n() } case "send": { const [i] = s; this.request.addEventListener("load", () => { if (typeof this.onResponse != "undefined") { const f = At(this.request, this.request.response); this.onResponse.call(this, { response: f, isMockedResponse: this[k], request: c, requestId: this.requestId }) } }); const a = typeof i == "string" ? l(i) : i, c = this.toFetchApiRequest(a); this[re] = c.clone(), (((o = this.onRequest) == null ? void 0 : o.call(this, { request: c, requestId: this.requestId })) || Promise.resolve()).finally(() => { if (!this[k]) return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...", this.request.readyState), jt && this.request.setRequestHeader(Ke, this.requestId), n() }); break } default: return n() } } }), H(this.request, "upload", te(this.request.upload, { setProperty: ([r, s], n) => { switch (r) { case "onloadstart": case "onprogress": case "onaboart": case "onerror": case "onload": case "ontimeout": case "onloadend": { const o = r.slice(2); this.registerUploadEvent(o, s) } }return n() }, methodCall: ([r, s], n) => { switch (r) { case "addEventListener": { const [o, i] = s; return this.registerUploadEvent(o, i), this.logger.info("upload.addEventListener", o, i), n() } } } })) } registerEvent(e, t) { const s = (this.events.get(e) || []).concat(t); this.events.set(e, s), this.logger.info('registered event "%s"', e, t) } registerUploadEvent(e, t) { const s = (this.uploadEvents.get(e) || []).concat(t); this.uploadEvents.set(e, s), this.logger.info('registered upload event "%s"', e, t) } respondWith(e) {
            return g(this, null, function* () {
                if (this[k] = !0, this[re]) { const s = yield Se(this[re]); this.trigger("loadstart", this.request.upload, { loaded: 0, total: s }), this.trigger("progress", this.request.upload, { loaded: s, total: s }), this.trigger("load", this.request.upload, { loaded: s, total: s }), this.trigger("loadend", this.request.upload, { loaded: s, total: s }) } this.logger.info("responding with a mocked response: %d %s", e.status, e.statusText), H(this.request, "status", e.status), H(this.request, "statusText", e.statusText), H(this.request, "responseURL", this.url.href), this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, { apply: (s, n, o) => { if (this.logger.info("getResponseHeader", o[0]), this.request.readyState < this.request.HEADERS_RECEIVED) return this.logger.info("headers not received yet, returning null"), null; const i = e.headers.get(o[0]); return this.logger.info('resolved response header "%s" to', o[0], i), i } }), this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {
                    apply: () => {
                        if (this.logger.info("getAllResponseHeaders"), this.request.readyState < this.request.HEADERS_RECEIVED) return this.logger.info("headers not received yet, returning empty string"), ""; const n = Array.from(e.headers.entries()).map(([o, i]) => `${o}: ${i}`).join(`\r
`); return this.logger.info("resolved all response headers to", n), n
                    }
                }), Object.defineProperties(this.request, { response: { enumerable: !0, configurable: !1, get: () => this.response }, responseText: { enumerable: !0, configurable: !1, get: () => this.responseText }, responseXML: { enumerable: !0, configurable: !1, get: () => this.responseXML } }); const t = yield Se(e.clone()); this.logger.info("calculated response body length", t), this.trigger("loadstart", this.request, { loaded: 0, total: t }), this.setReadyState(this.request.HEADERS_RECEIVED), this.setReadyState(this.request.LOADING); const r = () => { this.logger.info("finalizing the mocked response..."), this.setReadyState(this.request.DONE), this.trigger("load", this.request, { loaded: this.responseBuffer.byteLength, total: t }), this.trigger("loadend", this.request, { loaded: this.responseBuffer.byteLength, total: t }) }; if (e.body) { this.logger.info("mocked response has body, streaming..."); const s = e.body.getReader(), n = () => g(this, null, function* () { const { value: o, done: i } = yield s.read(); if (i) { this.logger.info("response body stream done!"), r(); return } o && (this.logger.info("read response body chunk:", o), this.responseBuffer = Lt(this.responseBuffer, o), this.trigger("progress", this.request, { loaded: this.responseBuffer.byteLength, total: t })), n() }); n() } else r()
            })
        } responseBufferToText() { return h(this.responseBuffer) } get response() { if (this.logger.info("getResponse (responseType: %s)", this.request.responseType), this.request.readyState !== this.request.DONE) return null; switch (this.request.responseType) { case "json": { const e = Ht(this.responseBufferToText()); return this.logger.info("resolved response JSON", e), e } case "arraybuffer": { const e = O(this.responseBuffer); return this.logger.info("resolved response ArrayBuffer", e), e } case "blob": { const e = this.request.getResponseHeader("Content-Type") || "text/plain", t = new Blob([this.responseBufferToText()], { type: e }); return this.logger.info("resolved response Blob (mime type: %s)", t, e), t } default: { const e = this.responseBufferToText(); return this.logger.info('resolving "%s" response type as text', this.request.responseType, e), e } } } get responseText() { if (S(this.request.responseType === "" || this.request.responseType === "text", "InvalidStateError: The object is in invalid state."), this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) return ""; const e = this.responseBufferToText(); return this.logger.info('getResponseText: "%s"', e), e } get responseXML() { if (S(this.request.responseType === "" || this.request.responseType === "document", "InvalidStateError: The object is in invalid state."), this.request.readyState !== this.request.DONE) return null; const e = this.request.getResponseHeader("Content-Type") || ""; return typeof DOMParser == "undefined" ? (console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."), null) : Dt(e) ? new DOMParser().parseFromString(this.responseBufferToText(), e) : null } errorWith(e) { this[k] = !0, this.logger.info("responding with an error"), this.setReadyState(this.request.DONE), this.trigger("error", this.request), this.trigger("loadend", this.request) } setReadyState(e) { if (this.logger.info("setReadyState: %d -> %d", this.request.readyState, e), this.request.readyState === e) { this.logger.info("ready state identical, skipping transition..."); return } H(this.request, "readyState", e), this.logger.info("set readyState to: %d", e), e !== this.request.UNSENT && (this.logger.info('triggerring "readystatechange" event...'), this.trigger("readystatechange", this.request)) } trigger(e, t, r) { const s = t[`on${e}`], n = It(t, e, r); this.logger.info('trigger "%s"', e, r || ""), typeof s == "function" && (this.logger.info('found a direct "%s" callback, calling...', e), s.call(t, n)); const o = t instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events; for (const [i, a] of o) i === e && (this.logger.info('found %d listener(s) for "%s" event, calling...', a.length, e), a.forEach(c => c.call(t, n))) } toFetchApiRequest(e) { this.logger.info("converting request to a Fetch API Request..."); const t = e instanceof Document ? e.documentElement.innerText : e, r = new Request(this.url.href, { method: this.method, headers: this.requestHeaders, credentials: this.request.withCredentials ? "include" : "same-origin", body: ["GET", "HEAD"].includes(this.method.toUpperCase()) ? null : t }), s = te(r.headers, { methodCall: ([n, o], i) => { switch (n) { case "append": case "set": { const [a, c] = o; this.request.setRequestHeader(a, c); break } case "delete": { const [a] = o; console.warn(`XMLHttpRequest: Cannot remove a "${a}" header from the Fetch API representation of the "${r.method} ${r.url}" request. XMLHttpRequest headers cannot be removed.`); break } }return i() } }); return H(r, "headers", s), this.logger.info("converted request to a Fetch API Request!", r), r }
    }; function Pe(e) { return typeof location == "undefined" ? new URL(e) : new URL(e.toString(), location.href) } function H(e, t, r) { Reflect.defineProperty(e, t, { writable: !0, enumerable: !0, value: r }) } function Bt({ emitter: e, logger: t }) { return new Proxy(globalThis.XMLHttpRequest, { construct(s, n, o) { t.info("constructed new XMLHttpRequest"); const i = Reflect.construct(s, n, o), a = Object.getOwnPropertyDescriptors(s.prototype); for (const u in a) Reflect.defineProperty(i, u, a[u]); const c = new Mt(i, t); return c.onRequest = function (p) { return g(this, arguments, function* ({ request: u, requestId: f }) { const m = new Z(u); this.logger.info("awaiting mocked response..."), this.logger.info('emitting the "request" event for %s listener(s)...', e.listenerCount("request")), (yield Ee({ request: u, requestId: f, controller: m, emitter: e, onResponse: b => g(this, null, function* () { yield this.respondWith(b) }), onRequestError: () => { this.errorWith(new TypeError("Network error")) }, onError: b => { this.logger.info("request errored!", { error: b }), b instanceof Error && this.errorWith(b) } })) || this.logger.info("no mocked response received, performing request as-is...") }) }, c.onResponse = function (_) { return g(this, arguments, function* ({ response: u, isMockedResponse: f, request: p, requestId: m }) { this.logger.info('emitting the "response" event for %s listener(s)...', e.listenerCount("response")), e.emit("response", { response: u, isMockedResponse: f, request: p, requestId: m }) }) }, c.request } }) } var Ie = class extends V { constructor() { super(Ie.interceptorSymbol) } checkEnvironment() { return Re("XMLHttpRequest") } setup() { const e = this.logger.extend("setup"); e.info('patching "XMLHttpRequest" module...'); const t = globalThis.XMLHttpRequest; S(!t[R], 'Failed to patch the "XMLHttpRequest" module: already patched.'), globalThis.XMLHttpRequest = Bt({ emitter: this.emitter, logger: this.logger }), e.info('native "XMLHttpRequest" module patched!', globalThis.XMLHttpRequest.name), Object.defineProperty(globalThis.XMLHttpRequest, R, { enumerable: !0, configurable: !0, value: !0 }), this.subscriptions.push(() => { Object.defineProperty(globalThis.XMLHttpRequest, R, { value: void 0 }), globalThis.XMLHttpRequest = t, e.info('native "XMLHttpRequest" module restored!', globalThis.XMLHttpRequest.name) }) } }, Oe = Ie; Oe.interceptorSymbol = Symbol("xhr"); function Ct(e = {}) { const t = [new xe, new Oe]; return ht(e, t) } return { init: Ct }
});
