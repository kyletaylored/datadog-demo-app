{"version":3,"file":"startRecording-eyaOsNnX.mjs","sources":["../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js","../app/node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/viewports.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/assembly.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js","../app/node_modules/@datadog/browser-rum/esm/domain/record/record.js","../app/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js","../app/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js","../app/node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js","../app/node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js","../app/node_modules/@datadog/browser-rum/esm/boot/startRecording.js"],"sourcesContent":["import { buildUrl } from '@datadog/browser-core';\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core';\nconst serializedNodeIds = new WeakMap();\nexport function hasSerializedNode(node) {\n    return serializedNodeIds.has(node);\n}\nexport function nodeAndAncestorsHaveSerializedNode(node) {\n    let current = node;\n    while (current) {\n        if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n            return false;\n        }\n        current = getParentNode(current);\n    }\n    return true;\n}\nexport function getSerializedNodeId(node) {\n    return serializedNodeIds.get(node);\n}\nexport function setSerializedNodeId(node, serializeNodeId) {\n    serializedNodeIds.set(node, serializeNodeId);\n}\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element, nodePrivacyLevel) {\n    /*\n     BROWSER SPEC NOTE: <input>, <select>\n     For some <input> elements, the `value` is an exceptional property/attribute that has the\n     value synced between el.value and el.getAttribute()\n     input[type=button,checkbox,hidden,image,radio,reset,submit]\n     */\n    const tagName = element.tagName;\n    const value = element.value;\n    if (shouldMaskNode(element, nodePrivacyLevel)) {\n        const type = element.type;\n        if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n            // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n            // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n            return value;\n        }\n        else if (!value || tagName === 'OPTION') {\n            // <Option> value provides no benefit\n            return;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (tagName === 'OPTION' || tagName === 'SELECT') {\n        return element.value;\n    }\n    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n        return;\n    }\n    return value;\n}\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//;\nexport const DATA_URI = /^data:.*,/i;\nexport function switchToAbsoluteUrl(cssText, cssHref) {\n    return cssText.replace(URL_IN_CSS_REF, (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) => {\n        const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;\n        if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n            return matchingSubstring;\n        }\n        const quote = singleQuote || doubleQuote || '';\n        return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`;\n    });\n}\nexport function makeUrlAbsolute(url, baseUrl) {\n    try {\n        return buildUrl(url, baseUrl).href;\n    }\n    catch (_a) {\n        return url;\n    }\n}\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/;\nexport function getValidTagName(tagName) {\n    const processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nexport function censoredImageForSize(width, height) {\n    return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`;\n}\n//# sourceMappingURL=serializationUtils.js.map","export const RecordType = {\n    FullSnapshot: 2,\n    IncrementalSnapshot: 3,\n    Meta: 4,\n    Focus: 6,\n    ViewEnd: 7,\n    VisualViewport: 8,\n    FrustrationRecord: 9,\n};\nexport const NodeType = {\n    Document: 0,\n    DocumentType: 1,\n    Element: 2,\n    Text: 3,\n    CDATA: 4,\n    DocumentFragment: 11,\n};\nexport const IncrementalSource = {\n    Mutation: 0,\n    MouseMove: 1,\n    MouseInteraction: 2,\n    Scroll: 3,\n    ViewportResize: 4,\n    Input: 5,\n    TouchMove: 6,\n    MediaInteraction: 7,\n    StyleSheetRule: 8,\n    // CanvasMutation : 9,\n    // Font : 10,\n};\nexport const MouseInteractionType = {\n    MouseUp: 0,\n    MouseDown: 1,\n    Click: 2,\n    ContextMenu: 3,\n    DblClick: 4,\n    Focus: 5,\n    Blur: 6,\n    TouchStart: 7,\n    TouchEnd: 9,\n};\nexport const MediaInteractionType = {\n    Play: 0,\n    Pause: 1,\n};\n//# sourceMappingURL=sessionReplayConstants.js.map","export function serializeStyleSheets(cssStyleSheets) {\n    if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n        return undefined;\n    }\n    return cssStyleSheets.map((cssStyleSheet) => {\n        const rules = cssStyleSheet.cssRules || cssStyleSheet.rules;\n        const cssRules = Array.from(rules, (cssRule) => cssRule.cssText);\n        const styleSheet = {\n            cssRules,\n            disabled: cssStyleSheet.disabled || undefined,\n            media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n        };\n        return styleSheet;\n    });\n}\n//# sourceMappingURL=serializeStyleSheets.js.map","import { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK, STABLE_ATTRIBUTES, isLongDataUrl, sanitizeDataUrl, } from '@datadog/browser-rum-core';\nimport { censoredImageForSize } from './serializationUtils';\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    const attributeValue = element.getAttribute(attributeName);\n    if (nodePrivacyLevel === NodePrivacyLevel.MASK &&\n        attributeName !== PRIVACY_ATTR_NAME &&\n        !STABLE_ATTRIBUTES.includes(attributeName) &&\n        attributeName !== configuration.actionNameAttribute) {\n        const tagName = element.tagName;\n        switch (attributeName) {\n            // Mask Attribute text content\n            case 'title':\n            case 'alt':\n            case 'placeholder':\n                return CENSORED_STRING_MARK;\n        }\n        // mask image URLs\n        if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n            // generate image with similar dimension than the original to have the same rendering behaviour\n            const image = element;\n            if (image.naturalWidth > 0) {\n                return censoredImageForSize(image.naturalWidth, image.naturalHeight);\n            }\n            const { width, height } = element.getBoundingClientRect();\n            if (width > 0 || height > 0) {\n                return censoredImageForSize(width, height);\n            }\n            // if we can't get the image size, fallback to the censored image\n            return CENSORED_IMG_MARK;\n        }\n        // mask source URLs\n        if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n            return CENSORED_IMG_MARK;\n        }\n        // mask <a> URLs\n        if (tagName === 'A' && attributeName === 'href') {\n            return CENSORED_STRING_MARK;\n        }\n        // mask data-* attributes\n        if (attributeValue && attributeName.startsWith('data-')) {\n            // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n            return CENSORED_STRING_MARK;\n        }\n        // mask iframe srcdoc\n        if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n            return CENSORED_STRING_MARK;\n        }\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    // Minimum Fix for customer.\n    if (isLongDataUrl(attributeValue)) {\n        return sanitizeDataUrl(attributeValue);\n    }\n    return attributeValue;\n}\n//# sourceMappingURL=serializeAttribute.js.map","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { isSafari } from '@datadog/browser-core';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    const safeAttrs = {};\n    const tagName = getValidTagName(element.tagName);\n    const doc = element.ownerDocument;\n    for (let i = 0; i < element.attributes.length; i += 1) {\n        const attribute = element.attributes.item(i);\n        const attributeName = attribute.name;\n        const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        const formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        const optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);\n        const cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' && element.sheet) {\n        const cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    const inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            delete safeAttrs.checked;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        const mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element only for full snapshot\n     */\n    let scrollTop;\n    let scrollLeft;\n    const serializationContext = options.serializationContext;\n    switch (serializationContext.status) {\n        case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n            scrollTop = Math.round(element.scrollTop);\n            scrollLeft = Math.round(element.scrollLeft);\n            if (scrollTop || scrollLeft) {\n                serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft });\n            }\n            break;\n        case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n            if (serializationContext.elementsScrollPositions.has(element)) {\n                ;\n                ({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element));\n            }\n            break;\n    }\n    if (scrollLeft) {\n        safeAttrs.rr_scrollLeft = scrollLeft;\n    }\n    if (scrollTop) {\n        safeAttrs.rr_scrollTop = scrollTop;\n    }\n    return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n    if (!cssStyleSheet) {\n        return null;\n    }\n    let rules;\n    try {\n        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n    }\n    catch (_a) {\n        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n    }\n    if (!rules) {\n        return null;\n    }\n    const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n    return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n    // Safari does not escape attribute selectors containing : properly\n    // https://bugs.webkit.org/show_bug.cgi?id=184604\n    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n        // This regex replaces [foo:bar] by [foo\\\\:bar]\n        const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n        return rule.cssText.replace(escapeColon, '$1\\\\$2');\n    }\n    return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n    // to the @import rule CSS text.\n    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return 'selectorText' in rule;\n}\n//# sourceMappingURL=serializeAttributes.js.map","import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';\nimport { NodeType } from '../../../types';\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, options) {\n    const serializedNode = serializeNode(node, options);\n    if (!serializedNode) {\n        return null;\n    }\n    // Try to reuse the previous id\n    const id = getSerializedNodeId(node) || generateNextId();\n    const serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    setSerializedNodeId(node, id);\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nlet _nextId = 1;\nexport function generateNextId() {\n    return _nextId++;\n}\nexport function serializeChildNodes(node, options) {\n    const result = [];\n    forEachChildNodes(node, (childNode) => {\n        const serializedChildNode = serializeNodeWithId(childNode, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nfunction serializeNode(node, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, options);\n        case node.DOCUMENT_FRAGMENT_NODE:\n            return serializeDocumentFragmentNode(node, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, options);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, options),\n        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n    };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n    const isShadowRoot = isNodeShadowRoot(element);\n    if (isShadowRoot) {\n        options.serializationContext.shadowRootsController.addShadowRoot(element);\n    }\n    return {\n        type: NodeType.DocumentFragment,\n        childNodes: serializeChildNodes(element, options),\n        isShadowRoot,\n        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, options) {\n    const tagName = getValidTagName(element.tagName);\n    const isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        const { width, height } = element.getBoundingClientRect();\n        return {\n            type: NodeType.Element,\n            tagName,\n            attributes: {\n                rr_width: `${width}px`,\n                rr_height: `${height}px`,\n                [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n            },\n            childNodes: [],\n            isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    const attributes = serializeAttributes(element, nodePrivacyLevel, options);\n    let childNodes = [];\n    if (hasChildNodes(element) &&\n        // Do not serialize style children as the css rules are already in the _cssText attribute\n        tagName !== 'style') {\n        // OBJECT POOLING OPTIMIZATION:\n        // We should not create a new object systematically as it could impact performances. Try to reuse\n        // the same object as much as possible, and clone it only if we need to.\n        let childNodesSerializationOptions;\n        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n            childNodesSerializationOptions = options;\n        }\n        else {\n            childNodesSerializationOptions = {\n                ...options,\n                parentNodePrivacyLevel: nodePrivacyLevel,\n                ignoreWhiteSpace: tagName === 'head',\n            };\n        }\n        childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n    }\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes,\n        isSVG,\n    };\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n    const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n    if (textContent === undefined) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\n//# sourceMappingURL=serializeNode.js.map","import { serializeNodeWithId } from './serializeNode';\nexport function serializeDocument(document, configuration, serializationContext) {\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializeNodeWithId(document, {\n        serializationContext,\n        parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n        configuration,\n    });\n}\n//# sourceMappingURL=serializeDocument.js.map","import { isNodeShadowHost } from '@datadog/browser-rum-core';\nexport function isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nexport function getEventTarget(event) {\n    if (event.composed === true && isNodeShadowHost(event.target)) {\n        return event.composedPath()[0];\n    }\n    return event.target;\n}\n//# sourceMappingURL=eventsUtils.js.map","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n    return (Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n        Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE);\n}\nexport const convertMouseEventToLayoutCoordinates = (clientX, clientY) => {\n    const visualViewport = window.visualViewport;\n    const normalized = {\n        layoutViewportX: clientX,\n        layoutViewportY: clientY,\n        visualViewportX: clientX,\n        visualViewportY: clientY,\n    };\n    if (!visualViewport) {\n        // On old browsers, we cannot normalize, so fallback to clientX/Y\n        return normalized;\n    }\n    else if (isVisualViewportFactoredIn(visualViewport)) {\n        // Typically Mobile Devices\n        normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n        normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n    }\n    else {\n        // Typically Desktop Devices\n        normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n        normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n    }\n    return normalized;\n};\nexport const getVisualViewport = (visualViewport) => ({\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width,\n});\n//# sourceMappingURL=viewports.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nexport function assembleIncrementalSnapshot(source, data) {\n    return {\n        data: {\n            source,\n            ...data,\n        },\n        type: RecordType.IncrementalSnapshot,\n        timestamp: timeStampNow(),\n    };\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListeners, addTelemetryDebug, throttle } from '@datadog/browser-core';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget, isTouchEvent } from '../eventsUtils';\nimport { convertMouseEventToLayoutCoordinates } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50;\nexport function trackMove(configuration, moveCb) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (hasSerializedNode(target)) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            const position = {\n                id: getSerializedNodeId(target),\n                timeOffset: 0,\n                x: coordinates.x,\n                y: coordinates.y,\n            };\n            moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));\n        }\n    }, MOUSE_MOVE_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, document, [\"mousemove\" /* DOM_EVENT.MOUSE_MOVE */, \"touchmove\" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\nexport function tryToComputeCoordinates(event) {\n    let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event;\n    if (window.visualViewport) {\n        const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y);\n        x = visualViewportX;\n        y = visualViewportY;\n    }\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n        if (event.isTrusted) {\n            addTelemetryDebug('mouse/touch event without x/y');\n        }\n        return undefined;\n    }\n    return { x, y };\n}\n//# sourceMappingURL=trackMove.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MouseInteractionType } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { tryToComputeCoordinates } from './trackMove';\nconst eventTypeToMouseInteraction = {\n    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n    // allows to reference such records from Frustration records.\n    //\n    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n    // convey such interaction. This would cleanly solve the issue since we would have\n    // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n    [\"pointerup\" /* DOM_EVENT.POINTER_UP */]: MouseInteractionType.MouseUp,\n    [\"mousedown\" /* DOM_EVENT.MOUSE_DOWN */]: MouseInteractionType.MouseDown,\n    [\"click\" /* DOM_EVENT.CLICK */]: MouseInteractionType.Click,\n    [\"contextmenu\" /* DOM_EVENT.CONTEXT_MENU */]: MouseInteractionType.ContextMenu,\n    [\"dblclick\" /* DOM_EVENT.DBL_CLICK */]: MouseInteractionType.DblClick,\n    [\"focus\" /* DOM_EVENT.FOCUS */]: MouseInteractionType.Focus,\n    [\"blur\" /* DOM_EVENT.BLUR */]: MouseInteractionType.Blur,\n    [\"touchstart\" /* DOM_EVENT.TOUCH_START */]: MouseInteractionType.TouchStart,\n    [\"touchend\" /* DOM_EVENT.TOUCH_END */]: MouseInteractionType.TouchEnd,\n};\nexport function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {\n    const handler = (event) => {\n        const target = getEventTarget(event);\n        if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const type = eventTypeToMouseInteraction[event.type];\n        let interaction;\n        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            interaction = { id, type, x: coordinates.x, y: coordinates.y };\n        }\n        else {\n            interaction = { id, type };\n        }\n        const record = {\n            id: recordIds.getIdForEvent(event),\n            ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction),\n        };\n        mouseInteractionCb(record);\n    };\n    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMouseInteraction.js.map","import { throttle, addEventListener } from '@datadog/browser-core';\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst SCROLL_OBSERVER_THRESHOLD = 100;\nexport function trackScroll(configuration, scrollCb, elementsScrollPositions, target = document) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const scrollPositions = target === document\n            ? {\n                scrollTop: getScrollY(),\n                scrollLeft: getScrollX(),\n            }\n            : {\n                scrollTop: Math.round(target.scrollTop),\n                scrollLeft: Math.round(target.scrollLeft),\n            };\n        elementsScrollPositions.set(target, scrollPositions);\n        scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {\n            id,\n            x: scrollPositions.scrollLeft,\n            y: scrollPositions.scrollTop,\n        }));\n    }, SCROLL_OBSERVER_THRESHOLD);\n    const { stop: removeListener } = addEventListener(configuration, target, \"scroll\" /* DOM_EVENT.SCROLL */, updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackScroll.js.map","import { throttle, addEventListeners, timeStampNow, noop } from '@datadog/browser-core';\nimport { initViewportObservable } from '@datadog/browser-rum-core';\nimport { IncrementalSource, RecordType } from '../../../types';\nimport { getVisualViewport } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;\nexport function trackViewportResize(configuration, viewportResizeCb) {\n    const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data) => {\n        viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));\n    });\n    return {\n        stop: () => {\n            viewportResizeSubscription.unsubscribe();\n        },\n    };\n}\nexport function trackVisualViewportResize(configuration, visualViewportResizeCb) {\n    const visualViewport = window.visualViewport;\n    if (!visualViewport) {\n        return { stop: noop };\n    }\n    const { throttled: updateDimension, cancel: cancelThrottle } = throttle(() => {\n        visualViewportResizeCb({\n            data: getVisualViewport(visualViewport),\n            type: RecordType.VisualViewport,\n            timestamp: timeStampNow(),\n        });\n    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, visualViewport, [\"resize\" /* DOM_EVENT.RESIZE */, \"scroll\" /* DOM_EVENT.SCROLL */], updateDimension, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackViewportResize.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MediaInteractionType } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackMediaInteraction(configuration, mediaInteractionCb) {\n    return addEventListeners(configuration, document, [\"play\" /* DOM_EVENT.PLAY */, \"pause\" /* DOM_EVENT.PAUSE */], (event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {\n            id: getSerializedNodeId(target),\n            type: event.type === \"play\" /* DOM_EVENT.PLAY */ ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        }));\n    }, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMediaInteraction.js.map","import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(styleSheetCb) {\n    function checkStyleSheetAndCallback(styleSheet, callback) {\n        if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {\n            callback(getSerializedNodeId(styleSheet.ownerNode));\n        }\n    }\n    const instrumentationStoppers = [\n        instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index }],\n            })));\n        }),\n        instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index }],\n            })));\n        }),\n    ];\n    if (typeof CSSGroupingRule !== 'undefined') {\n        instrumentGroupingCSSRuleClass(CSSGroupingRule);\n    }\n    else {\n        instrumentGroupingCSSRuleClass(CSSMediaRule);\n        instrumentGroupingCSSRuleClass(CSSSupportsRule);\n    }\n    function instrumentGroupingCSSRuleClass(cls) {\n        instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index || 0);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        adds: [{ rule, index: path }],\n                    }));\n                }\n            });\n        }), instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        removes: [{ index: path }],\n                    }));\n                }\n            });\n        }));\n    }\n    return {\n        stop: () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        },\n    };\n}\nexport function getPathToNestedCSSRule(rule) {\n    const path = [];\n    let currentRule = rule;\n    while (currentRule.parentRule) {\n        const rules = Array.from(currentRule.parentRule.cssRules);\n        const index = rules.indexOf(currentRule);\n        path.unshift(index);\n        currentRule = currentRule.parentRule;\n    }\n    // A rule may not be attached to a stylesheet\n    if (!currentRule.parentStyleSheet) {\n        return;\n    }\n    const rules = Array.from(currentRule.parentStyleSheet.cssRules);\n    const index = rules.indexOf(currentRule);\n    path.unshift(index);\n    return path;\n}\n//# sourceMappingURL=trackStyleSheet.js.map","import { addEventListeners, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackFocus(configuration, focusCb) {\n    return addEventListeners(configuration, window, [\"focus\" /* DOM_EVENT.FOCUS */, \"blur\" /* DOM_EVENT.BLUR */], () => {\n        focusCb({\n            data: { has_focus: document.hasFocus() },\n            type: RecordType.Focus,\n            timestamp: timeStampNow(),\n        });\n    });\n}\n//# sourceMappingURL=trackFocus.js.map","import { RecordType } from '../../../types';\nexport function trackFrustration(lifeCycle, frustrationCb, recordIds) {\n    const frustrationSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n        var _a, _b;\n        if (data.rawRumEvent.type === \"action\" /* RumEventType.ACTION */ &&\n            data.rawRumEvent.action.type === \"click\" /* ActionType.CLICK */ &&\n            ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) &&\n            'events' in data.domainContext &&\n            data.domainContext.events &&\n            data.domainContext.events.length) {\n            frustrationCb({\n                timestamp: data.rawRumEvent.date,\n                type: RecordType.FrustrationRecord,\n                data: {\n                    frustrationTypes: data.rawRumEvent.action.frustration.type,\n                    recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n                },\n            });\n        }\n    });\n    return {\n        stop: () => {\n            frustrationSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFrustration.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackViewEnd(lifeCycle, viewEndCb) {\n    const viewEndSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, () => {\n        viewEndCb({\n            timestamp: timeStampNow(),\n            type: RecordType.ViewEnd,\n        });\n    });\n    return {\n        stop: () => {\n            viewEndSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackViewEnd.js.map","import { instrumentSetter, addEventListeners, noop } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, inputCb, target = document) {\n    const defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n    const lastInputStateMap = new WeakMap();\n    const isShadowRoot = target !== document;\n    const { stop: stopEventListeners } = addEventListeners(configuration, target, \n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [\"change\" /* DOM_EVENT.CHANGE */] : [\"input\" /* DOM_EVENT.INPUT */, \"change\" /* DOM_EVENT.CHANGE */], (event) => {\n        const target = getEventTarget(event);\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement ||\n            target instanceof HTMLSelectElement) {\n            onElementChange(target);\n        }\n    }, {\n        capture: true,\n        passive: true,\n    });\n    let stopPropertySetterInstrumentation;\n    if (!isShadowRoot) {\n        const instrumentationStoppers = [\n            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n        ];\n        stopPropertySetterInstrumentation = () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        };\n    }\n    else {\n        stopPropertySetterInstrumentation = noop;\n    }\n    return {\n        stop: () => {\n            stopPropertySetterInstrumentation();\n            stopEventListeners();\n        },\n    };\n    function onElementChange(target) {\n        const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const type = target.type;\n        let inputState;\n        if (type === 'radio' || type === 'checkbox') {\n            if (shouldMaskNode(target, nodePrivacyLevel)) {\n                return;\n            }\n            inputState = { isChecked: target.checked };\n        }\n        else {\n            const value = getElementInputValue(target, nodePrivacyLevel);\n            if (value === undefined) {\n                return;\n            }\n            inputState = { text: value };\n        }\n        // Can be multiple changes on the same node within the same batched mutation observation.\n        cbWithDedup(target, inputState);\n        // If a radio was checked, other radios with the same name attribute will be unchecked.\n        const name = target.name;\n        if (type === 'radio' && name && target.checked) {\n            document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el) => {\n                if (el !== target) {\n                    // TODO: Consider the privacy implications for various differing input privacy levels\n                    cbWithDedup(el, { isChecked: false });\n                }\n            });\n        }\n    }\n    /**\n     * There can be multiple changes on the same node within the same batched mutation observation.\n     */\n    function cbWithDedup(target, inputState) {\n        if (!hasSerializedNode(target)) {\n            return;\n        }\n        const lastInputState = lastInputStateMap.get(target);\n        if (!lastInputState ||\n            lastInputState.text !== inputState.text ||\n            lastInputState.isChecked !== inputState.isChecked) {\n            lastInputStateMap.set(target, inputState);\n            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {\n                id: getSerializedNodeId(target),\n                ...inputState,\n            }));\n        }\n    }\n}\n//# sourceMappingURL=trackInput.js.map","import { noop, throttle, requestIdleCallback } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100;\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16;\nexport function createMutationBatch(processMutationBatch) {\n    let cancelScheduledFlush = noop;\n    let pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n        leading: false,\n    });\n    return {\n        addMutations: (mutations) => {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });\n            }\n            pendingMutations.push(...mutations);\n        },\n        flush,\n        stop: () => {\n            cancelScheduledFlush();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=mutationBatch.js.map","import { monitor, noop } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes, getNodePrivacyLevel, getTextContent, NodePrivacyLevel, } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, serializeNodeWithId, serializeAttribute, } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, shadowRootsController, target) {\n    const MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop, flush: noop };\n    }\n    const mutationBatch = createMutationBatch((mutations) => {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);\n    });\n    const observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(target, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    return {\n        stop: () => {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n        flush: () => {\n            mutationBatch.flush();\n        },\n    };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController) {\n    const nodePrivacyLevelCache = new Map();\n    mutations\n        .filter((mutation) => mutation.type === 'childList')\n        .forEach((mutation) => {\n        mutation.removedNodes.forEach((removedNode) => {\n            traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n        });\n    });\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected &&\n        nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n        getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n            NodePrivacyLevel.HIDDEN);\n    const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === 'childList'), configuration, shadowRootsController, nodePrivacyLevelCache);\n    const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds, removes, texts, attributes }));\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    const addedAndMovedNodes = new Set();\n    const removedNodes = new Map();\n    for (const mutation of mutations) {\n        mutation.addedNodes.forEach((node) => {\n            addedAndMovedNodes.add(node);\n        });\n        mutation.removedNodes.forEach((node) => {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    const serializedNodeIds = new Set();\n    const addedNodeMutations = [];\n    for (const node of sortedAddedAndMovedNodes) {\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        const serializedNode = serializeNodeWithId(node, {\n            serializedNodeIds,\n            parentNodePrivacyLevel,\n            serializationContext: { status: 2 /* SerializationContextStatus.MUTATION */, shadowRootsController },\n            configuration,\n        });\n        if (!serializedNode) {\n            continue;\n        }\n        const parentNode = getParentNode(node);\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: getSerializedNodeId(parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    const removedNodeMutations = [];\n    removedNodes.forEach((parent, node) => {\n        if (hasSerializedNode(node)) {\n            removedNodeMutations.push({\n                parentId: getSerializedNodeId(parent),\n                id: getSerializedNodeId(node),\n            });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n    }\n    function getNextSibling(node) {\n        let nextSibling = node.nextSibling;\n        while (nextSibling) {\n            if (hasSerializedNode(nextSibling)) {\n                return getSerializedNodeId(nextSibling);\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {\n    var _a;\n    const textMutations = [];\n    // Deduplicate mutations based on their target node\n    const handledNodes = new Set();\n    const filteredMutations = mutations.filter((mutation) => {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (const mutation of filteredMutations) {\n        const value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id: getSerializedNodeId(mutation.target),\n            // TODO: pass a valid \"ignoreWhiteSpace\" argument\n            value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {\n    const attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    const handledElements = new Map();\n    const filteredMutations = mutations.filter((mutation) => {\n        const handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    const emittedMutations = new Map();\n    for (const mutation of filteredMutations) {\n        const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n        let transformedValue;\n        if (mutation.attributeName === 'value') {\n            const inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        let emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = {\n                id: getSerializedNodeId(mutation.target),\n                attributes: {},\n            };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort((a, b) => {\n        const position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n    if (isNodeShadowHost(removedNode)) {\n        shadowDomRemovedCallback(removedNode.shadowRoot);\n    }\n    forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));\n}\n//# sourceMappingURL=trackMutation.js.map","export function createElementsScrollPositions() {\n    const scrollPositionsByElement = new WeakMap();\n    return {\n        set(element, scrollPositions) {\n            if (element === document && !document.scrollingElement) {\n                // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n                // in some cases scrolling elements can not be defined, we don't support those for now\n                return;\n            }\n            scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);\n        },\n        get(element) {\n            return scrollPositionsByElement.get(element);\n        },\n        has(element) {\n            return scrollPositionsByElement.has(element);\n        },\n    };\n}\n//# sourceMappingURL=elementsScrollPositions.js.map","import { trackInput, trackMutation, trackScroll } from './trackers';\nexport const initShadowRootsController = (configuration, callback, elementsScrollPositions) => {\n    const controllerByShadowRoot = new Map();\n    const shadowRootsController = {\n        addShadowRoot: (shadowRoot) => {\n            if (controllerByShadowRoot.has(shadowRoot)) {\n                return;\n            }\n            const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot);\n            // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n            const inputTracker = trackInput(configuration, callback, shadowRoot);\n            // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n            const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot);\n            controllerByShadowRoot.set(shadowRoot, {\n                flush: () => mutationTracker.flush(),\n                stop: () => {\n                    mutationTracker.stop();\n                    inputTracker.stop();\n                    scrollTracker.stop();\n                },\n            });\n        },\n        removeShadowRoot: (shadowRoot) => {\n            const entry = controllerByShadowRoot.get(shadowRoot);\n            if (!entry) {\n                // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n                return;\n            }\n            entry.stop();\n            controllerByShadowRoot.delete(shadowRoot);\n        },\n        stop: () => {\n            controllerByShadowRoot.forEach(({ stop }) => stop());\n        },\n        flush: () => {\n            controllerByShadowRoot.forEach(({ flush }) => flush());\n        },\n    };\n    return shadowRootsController;\n};\n//# sourceMappingURL=shadowRootsController.js.map","import { getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core';\nimport { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport { serializeDocument } from './serialization';\nimport { getVisualViewport } from './viewports';\nexport function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, fullSnapshotCallback) {\n    const takeFullSnapshot = (timestamp = timeStampNow(), serializationContext = {\n        status: 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */,\n        elementsScrollPositions,\n        shadowRootsController,\n    }) => {\n        const { width, height } = getViewportDimension();\n        const records = [\n            {\n                data: {\n                    height,\n                    href: window.location.href,\n                    width,\n                },\n                type: RecordType.Meta,\n                timestamp,\n            },\n            {\n                data: {\n                    has_focus: document.hasFocus(),\n                },\n                type: RecordType.Focus,\n                timestamp,\n            },\n            {\n                data: {\n                    node: serializeDocument(document, configuration, serializationContext),\n                    initialOffset: {\n                        left: getScrollX(),\n                        top: getScrollY(),\n                    },\n                },\n                type: RecordType.FullSnapshot,\n                timestamp,\n            },\n        ];\n        if (window.visualViewport) {\n            records.push({\n                data: getVisualViewport(window.visualViewport),\n                type: RecordType.VisualViewport,\n                timestamp,\n            });\n        }\n        return records;\n    };\n    fullSnapshotCallback(takeFullSnapshot());\n    const { unsubscribe } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n        flushMutations();\n        fullSnapshotCallback(takeFullSnapshot(view.startClocks.timeStamp, {\n            shadowRootsController,\n            status: 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */,\n            elementsScrollPositions,\n        }));\n    });\n    return {\n        stop: unsubscribe,\n    };\n}\n//# sourceMappingURL=startFullSnapshots.js.map","export function initRecordIds() {\n    const recordIds = new WeakMap();\n    let nextId = 1;\n    return {\n        getIdForEvent(event) {\n            if (!recordIds.has(event)) {\n                recordIds.set(event, nextId++);\n            }\n            return recordIds.get(event);\n        },\n    };\n}\n//# sourceMappingURL=recordIds.js.map","import { sendToExtension } from '@datadog/browser-core';\nimport * as replayStats from '../replayStats';\nimport { trackFocus, trackFrustration, trackInput, trackMediaInteraction, trackMouseInteraction, trackMove, trackMutation, trackScroll, trackStyleSheet, trackViewEnd, trackViewportResize, trackVisualViewportResize, } from './trackers';\nimport { createElementsScrollPositions } from './elementsScrollPositions';\nimport { initShadowRootsController } from './shadowRootsController';\nimport { startFullSnapshots } from './startFullSnapshots';\nimport { initRecordIds } from './recordIds';\nexport function record(options) {\n    const { emit, configuration, lifeCycle } = options;\n    // runtime checks for user options\n    if (!emit) {\n        throw new Error('emit function is required');\n    }\n    const emitAndComputeStats = (record) => {\n        emit(record);\n        sendToExtension('record', { record });\n        const view = options.viewHistory.findView();\n        replayStats.addRecord(view.id);\n    };\n    const elementsScrollPositions = createElementsScrollPositions();\n    const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions);\n    const { stop: stopFullSnapshots } = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, (records) => records.forEach((record) => emitAndComputeStats(record)));\n    function flushMutations() {\n        shadowRootsController.flush();\n        mutationTracker.flush();\n    }\n    const recordIds = initRecordIds();\n    const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document);\n    const trackers = [\n        mutationTracker,\n        trackMove(configuration, emitAndComputeStats),\n        trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n        trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n        trackViewportResize(configuration, emitAndComputeStats),\n        trackInput(configuration, emitAndComputeStats),\n        trackMediaInteraction(configuration, emitAndComputeStats),\n        trackStyleSheet(emitAndComputeStats),\n        trackFocus(configuration, emitAndComputeStats),\n        trackVisualViewportResize(configuration, emitAndComputeStats),\n        trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n        trackViewEnd(lifeCycle, (viewEndRecord) => {\n            flushMutations();\n            emitAndComputeStats(viewEndRecord);\n        }),\n    ];\n    return {\n        stop: () => {\n            shadowRootsController.stop();\n            trackers.forEach((tracker) => tracker.stop());\n            stopFullSnapshots();\n        },\n        flushMutations,\n        shadowRootsController,\n    };\n}\n//# sourceMappingURL=record.js.map","export function buildReplayPayload(data, metadata, rawSegmentBytesCount) {\n    const formData = new FormData();\n    formData.append('segment', new Blob([data], {\n        type: 'application/octet-stream',\n    }), `${metadata.session.id}-${metadata.start}`);\n    const metadataAndSegmentSizes = {\n        raw_segment_size: rawSegmentBytesCount,\n        compressed_segment_size: data.byteLength,\n        ...metadata,\n    };\n    const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);\n    formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }));\n    return { data: formData, bytesCount: data.byteLength };\n}\n//# sourceMappingURL=buildReplayPayload.js.map","import { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nexport function createSegment({ context, creationReason, encoder, }) {\n    let encodedBytesCount = 0;\n    const viewId = context.view.id;\n    const metadata = {\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser',\n        ...context,\n    };\n    replayStats.addSegment(viewId);\n    function addRecord(record, callback) {\n        metadata.start = Math.min(metadata.start, record.timestamp);\n        metadata.end = Math.max(metadata.end, record.timestamp);\n        metadata.records_count += 1;\n        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);\n        const prefix = encoder.isEmpty ? '{\"records\":[' : ',';\n        encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n            encodedBytesCount += additionalEncodedBytesCount;\n            callback(encodedBytesCount);\n        });\n    }\n    function flush(callback) {\n        if (encoder.isEmpty) {\n            throw new Error('Empty segment flushed');\n        }\n        encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`);\n        encoder.finish((encoderResult) => {\n            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);\n            callback(metadata, encoderResult);\n        });\n    }\n    return { addRecord, flush };\n}\n//# sourceMappingURL=segment.js.map","import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { createSegment } from './segment';\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {\n    return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n    let state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, () => {\n        flushSegment('view_change');\n    });\n    const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_EXITED */, (pageExitEvent) => {\n        flushSegment(pageExitEvent.reason);\n    });\n    function flushSegment(flushReason) {\n        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n            state.segment.flush((metadata, encoderResult) => {\n                const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);\n                if (isPageExitReason(flushReason)) {\n                    httpRequest.sendOnExit(payload);\n                }\n                else {\n                    httpRequest.send(payload);\n                }\n            });\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (flushReason !== 'stop') {\n            state = {\n                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n                nextSegmentCreationReason: flushReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* SegmentCollectionStatus.Stopped */,\n            };\n        }\n    }\n    return {\n        addRecord: (record) => {\n            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n                return;\n            }\n            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n                const context = getSegmentContext();\n                if (!context) {\n                    return;\n                }\n                state = {\n                    status: 1 /* SegmentCollectionStatus.SegmentPending */,\n                    segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n                    expirationTimeoutId: setTimeout(() => {\n                        flushSegment('segment_duration_limit');\n                    }, SEGMENT_DURATION_LIMIT),\n                };\n            }\n            state.segment.addRecord(record, (encodedBytesCount) => {\n                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n                    flushSegment('segment_bytes_limit');\n                }\n            });\n        },\n        stop: () => {\n            flushSegment('stop');\n            unsubscribeViewCreated();\n            unsubscribePageExited();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewHistory) {\n    const session = sessionManager.findTrackedSession();\n    const viewContext = viewHistory.findView();\n    if (!session || !viewContext) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: session.id,\n        },\n        view: {\n            id: viewContext.id,\n        },\n    };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60000) {\n    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}\n//# sourceMappingURL=segmentCollection.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRecordBridge(viewHistory) {\n    const bridge = getEventBridge();\n    return {\n        addRecord: (record) => {\n            // Get the current active view, not at the time of the record, aligning with the segment logic.\n            // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n            // However the risk is minimal. We could address the issue when potential negative impact are identified.\n            const view = viewHistory.findView();\n            bridge.send('record', record, view.id);\n        },\n    };\n}\n//# sourceMappingURL=startRecordBridge.js.map","import { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core';\nimport { record } from '../domain/record';\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection';\nimport { startRecordBridge } from '../domain/startRecordBridge';\nexport function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, httpRequest) {\n    const cleanupTasks = [];\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const replayRequest = httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError);\n    let addRecord;\n    if (!canUseEventBridge()) {\n        const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);\n        addRecord = segmentCollection.addRecord;\n        cleanupTasks.push(segmentCollection.stop);\n    }\n    else {\n        ;\n        ({ addRecord } = startRecordBridge(viewHistory));\n    }\n    const { stop: stopRecording } = record({\n        emit: addRecord,\n        configuration,\n        lifeCycle,\n        viewHistory,\n    });\n    cleanupTasks.push(stopRecording);\n    return {\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=startRecording.js.map"],"names":["serializedNodeIds","hasSerializedNode","node","nodeAndAncestorsHaveSerializedNode","current","isNodeShadowRoot","getParentNode","getSerializedNodeId","setSerializedNodeId","serializeNodeId","getElementInputValue","element","nodePrivacyLevel","tagName","value","shouldMaskNode","type","CENSORED_STRING_MARK","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","url","quote","makeUrlAbsolute","baseUrl","buildUrl","TAG_NAME_REGEX","getValidTagName","processedTagName","censoredImageForSize","width","height","RecordType","NodeType","IncrementalSource","MouseInteractionType","MediaInteractionType","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRule","serializeAttribute","attributeName","configuration","NodePrivacyLevel","attributeValue","PRIVACY_ATTR_NAME","STABLE_ATTRIBUTES","image","CENSORED_IMG_MARK","isLongDataUrl","sanitizeDataUrl","serializeAttributes","options","safeAttrs","doc","i","formValue","optionElement","stylesheet","s","getCssRulesString","inputElement","mediaElement","scrollTop","scrollLeft","serializationContext","styleSheetCssText","isSafari","getCssRuleStringForSafari","getCssRuleString","rule","isCSSStyleRule","escapeColon","isCSSImportRule","serializeNodeWithId","serializedNode","serializeNode","id","generateNextId","serializedNodeWithId","_nextId","serializeChildNodes","result","forEachChildNodes","childNode","serializedChildNode","serializeDocumentNode","serializeDocumentFragmentNode","serializeDocumentTypeNode","serializeElementNode","serializeTextNode","serializeCDataNode","document","isShadowRoot","documentType","isSVG","isSVGElement","reducePrivacyLevel","getNodeSelfPrivacyLevel","PRIVACY_ATTR_VALUE_HIDDEN","attributes","childNodes","hasChildNodes","childNodesSerializationOptions","el","textNode","textContent","getTextContent","serializeDocument","isTouchEvent","event","getEventTarget","isNodeShadowHost","TOLERANCE","isVisualViewportFactoredIn","visualViewport","convertMouseEventToLayoutCoordinates","clientX","clientY","normalized","getVisualViewport","assembleIncrementalSnapshot","source","data","timeStampNow","MOUSE_MOVE_OBSERVER_THRESHOLD","trackMove","moveCb","updatePosition","cancelThrottle","throttle","target","coordinates","tryToComputeCoordinates","position","removeListener","addEventListeners","x","y","visualViewportX","visualViewportY","addTelemetryDebug","eventTypeToMouseInteraction","trackMouseInteraction","mouseInteractionCb","recordIds","handler","getNodePrivacyLevel","interaction","record","SCROLL_OBSERVER_THRESHOLD","trackScroll","scrollCb","elementsScrollPositions","scrollPositions","getScrollY","getScrollX","addEventListener","VISUAL_VIEWPORT_OBSERVER_THRESHOLD","trackViewportResize","viewportResizeCb","viewportResizeSubscription","initViewportObservable","trackVisualViewportResize","visualViewportResizeCb","noop","updateDimension","trackMediaInteraction","mediaInteractionCb","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","styleSheet","callback","instrumentationStoppers","instrumentMethod","index","instrumentGroupingCSSRuleClass","cls","path","getPathToNestedCSSRule","stopper","currentRule","trackFocus","focusCb","trackFrustration","lifeCycle","frustrationCb","frustrationSubscription","_a","_b","e","trackViewEnd","viewEndCb","viewEndSubscription","trackInput","inputCb","defaultPrivacyLevel","lastInputStateMap","stopEventListeners","onElementChange","stopPropertySetterInstrumentation","instrumentSetter","inputState","cbWithDedup","name","lastInputState","MUTATION_PROCESS_MAX_DELAY","MUTATION_PROCESS_MIN_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","flush","throttledFlush","mutations","requestIdleCallback","trackMutation","mutationCallback","shadowRootsController","MutationObserver","getMutationObserverConstructor","mutationBatch","processMutations","observer","monitor","nodePrivacyLevelCache","mutation","removedNode","traverseRemovedShadowDom","filteredMutations","adds","removes","hasBeenSerialized","processChildListMutations","texts","processCharacterDataMutations","processAttributesMutations","addedAndMovedNodes","removedNodes","sortedAddedAndMovedNodes","sortAddedAndMovedNodes","addedNodeMutations","parentNodePrivacyLevel","parentNode","getNextSibling","removedNodeMutations","parent","nextSibling","textMutations","handledNodes","attributeMutations","handledElements","handledAttributes","emittedMutations","privacyLevel","transformedValue","inputValue","emittedMutation","nodes","a","b","shadowDomRemovedCallback","createElementsScrollPositions","scrollPositionsByElement","initShadowRootsController","controllerByShadowRoot","shadowRoot","mutationTracker","inputTracker","scrollTracker","entry","stop","startFullSnapshots","flushMutations","fullSnapshotCallback","takeFullSnapshot","timestamp","getViewportDimension","records","unsubscribe","view","initRecordIds","nextId","emit","emitAndComputeStats","sendToExtension","replayStats.addRecord","stopFullSnapshots","trackers","viewEndRecord","tracker","buildReplayPayload","metadata","rawSegmentBytesCount","formData","metadataAndSegmentSizes","serializedMetadataAndSegmentSizes","createSegment","context","creationReason","encoder","encodedBytesCount","viewId","replayStats.getSegmentsCount","replayStats.addSegment","addRecord","prefix","additionalEncodedBytesCount","encoderResult","replayStats.addWroteData","SEGMENT_DURATION_LIMIT","ONE_SECOND","SEGMENT_BYTES_LIMIT","startSegmentCollection","sessionManager","viewHistory","httpRequest","doStartSegmentCollection","computeSegmentContext","getSegmentContext","state","unsubscribeViewCreated","flushSegment","unsubscribePageExited","pageExitEvent","flushReason","payload","isPageExitReason","clearTimeout","setTimeout","applicationId","session","viewContext","startRecordBridge","bridge","getEventBridge","startRecording","cleanupTasks","reportError","error","replayRequest","createHttpRequest","canUseEventBridge","segmentCollection","stopRecording","task"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]}